// Simple Synchronous RAM Module
module simple_sync_ram #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 4
)(
    input wire clk,
    input wire we, // Write Enable: 1=Write, 0=Read
    input wire [ADDR_WIDTH-1:0] addr,
    input wire [DATA_WIDTH-1:0] din,
    output reg [DATA_WIDTH-1:0] dout
);

    // Memory array
    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];

    always @(posedge clk) begin
        if (we) begin
            mem[addr] <= din;      // Write operation
        end
        dout <= mem[addr];         // Read is always available (read-during-write = new data)
    end

endmodule
// Testbench for Simple Synchronous RAM
`timescale 1ns/1ps

module simple_sync_ram_tb;

    parameter DATA_WIDTH = 8;
    parameter ADDR_WIDTH = 4;

    reg clk;
    reg we;
    reg [ADDR_WIDTH-1:0] addr;
    reg [DATA_WIDTH-1:0] din;
    wire [DATA_WIDTH-1:0] dout;

    // Instantiate the RAM
    simple_sync_ram #(.DATA_WIDTH(DATA_WIDTH), .ADDR_WIDTH(ADDR_WIDTH)) uut (
        .clk(clk),
        .we(we),
        .addr(addr),
        .din(din),
        .dout(dout)
    );

    // Clock generation
    always #5 clk = ~clk;

    initial begin
        $display("==== Synchronous RAM Testbench ====");
        clk = 0;
        we = 0;
        addr = 0;
        din = 0;

        // Write some values into memory
        @(negedge clk); we = 1; addr = 4'd0; din = 8'hA5;
        @(negedge clk); addr = 4'd1; din = 8'h5A;
        @(negedge clk); addr = 4'd2; din = 8'hFF;
        @(negedge clk); addr = 4'd3; din = 8'h00;
        @(negedge clk); we = 0; // Stop writing

        // Read back the values
        @(negedge clk); addr = 4'd0;
        @(negedge clk);
        $display("Read addr 0: dout = %h (expected A5)", dout);
        @(negedge clk); addr = 4'd1;
        @(negedge clk);
        $display("Read addr 1: dout = %h (expected 5A)", dout);
        @(negedge clk); addr = 4'd2;
        @(negedge clk);
        $display("Read addr 2: dout = %h (expected FF)", dout);
        @(negedge clk); addr = 4'd3;
        @(negedge clk);
        $display("Read addr 3: dout = %h (expected 00)", dout);

        // Check write-during-read
        @(negedge clk); we = 1; addr = 4'd0; din = 8'h12;
        @(negedge clk); we = 0; addr = 4'd0;
        @(negedge clk);
        $display("Overwrite addr 0: dout = %h (expected 12)", dout);

        $finish;
    end

endmodule
# Simple Synchronous RAM (Verilog)

## Files

- `simple_sync_ram.v`: The RAM module.
- `simple_sync_ram_tb.v`: Testbench demonstrating RAM functionality.

## Features

- Parameterized data and address width.
- Synchronous write and read on rising clock edge.
- Simple interface: `clk`, `we`, `addr`, `din`, `dout`.

## How to Simulate

1. Compile both files using your favorite Verilog simulator (Icarus Verilog, ModelSim, etc.):
   ```
   iverilog -o ram_sim simple_sync_ram.v simple_sync_ram_tb.v
   vvp ram_sim
   ```
2. You should see output showing read/write operations and their expected values.

## Expected Output

```
==== Synchronous RAM Testbench ====
Read addr 0: dout = a5 (expected A5)
Read addr 1: dout = 5a (expected 5A)
Read addr 2: dout = ff (expected FF)
Read addr 3: dout = 00 (expected 00)
Overwrite addr 0: dout = 12 (expected 12)
```

---
You can modify `DATA_WIDTH` and `ADDR_WIDTH` in both files to increase RAM size or data width.
